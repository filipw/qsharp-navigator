<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Monaco Q# Editor</title>
  <style>
    html, body, #container {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
      -webkit-text-size-adjust: 100%;
    }
    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #1e1e1e;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      z-index: 1000;
    }
    .loading-spinner {
      border: 4px solid rgba(255, 255, 255, 0.1);
      border-radius: 50%;
      border-top: 4px solid #ffffff;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin-right: 10px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .loading-text {
      font-size: 16px;
    }
  </style>


  <script>
    window.MonacoEnvironment = {
      getWorkerUrl: function(workerId, label) {
        console.log("getWorkerUrl called for workerId:", workerId, "label:", label);
        const workerCode = `
          self.MonacoEnvironment = {
            baseUrl: 'http://localhost:8080/'
          };
          importScripts('http://localhost:8080/vs/base/worker/workerMain.js');
        `;
        const blob = new Blob([workerCode], { type: 'text/javascript' });
        const blobUrl = URL.createObjectURL(blob);
        console.log("Returning blob URL:", blobUrl);
        return blobUrl;
      }
    };
  </script>

  <link rel="stylesheet" data-name="vs/editor/editor.main"
        href="http://localhost:8080/vs/editor/editor.main.css"
        crossorigin="anonymous">
        <script src="http://localhost:8080/vs/loader.js"
            crossorigin="anonymous"></script>
        <script src="http://localhost:8080/wasmLoader.bundle.js"></script>
</head>
<body>
  <div id="container"></div>
  <div id="loading" class="loading-overlay">
    <div class="loading-spinner"></div>
    <div class="loading-text">Loading Q# Editor...</div>
  </div>
  
  <script>
    // Global error handler
    window.onerror = function(message, source, lineno, colno, error) {
      console.error("Global error caught:", message, source, lineno, colno, error);
      try {
        window.webkit.messageHandlers.logMessage.postMessage({
          level: "error",
          message: "Global error: " + message + " at " + source + ":" + lineno + ":" + colno
        });
      } catch (e) {}
      return false;
    };

    function logMessage(level, message) {
      console.log("[" + level.toUpperCase() + "] " + message);
      try {
        window.webkit.messageHandlers.logMessage.postMessage({
          level: level,
          message: message
        });
      } catch (e) {}
    }

    // utility functions for conversion between Monaco and LS formats
    function monacoPositionToLsPosition(position) {
      return { line: position.lineNumber - 1, character: position.column - 1 };
    }

    function lsRangeToMonacoRange(range) {
      if (!range) return null;
      return new monaco.Range(
        range.start.line + 1,
        range.start.character + 1,
        range.end.line + 1,
        range.end.character + 1
      );
    }

    function monacoRangetoLsRange(range) {
      return {
        start: {
          line: range.startLineNumber - 1,
          character: range.startColumn - 1,
        },
        end: { line: range.endLineNumber - 1, character: range.endColumn - 1 },
      };
    }

    window.QSharpLanguageService = {
      editor: null,
      monaco: null,
      isInitialized: false,
      
      initialize: async function(wasmPath, lsWorkerPath, compilerWorkerPath) {
        try {
          logMessage("info", "Initializing Q# language service");
          
          if (!window.monaco) {
            await this.loadMonaco();
          }
          
          this.setupQSharpLanguage();
          
          this.registerMonacoProviders();
          this.createEditor();
          
          this.isInitialized = true;
          logMessage("info", "Q# language service initialized successfully");
          
          // Notify Swift
          window.webkit.messageHandlers.wasmServiceInitialized.postMessage({
            success: true,
            message: "Language service initialized successfully"
          });
          
          return true;
        } catch (error) {
          logMessage("error", "Failed to initialize Q# language service: " + error.toString());
          
          // Notify Swift of error
          window.webkit.messageHandlers.wasmServiceInitialized.postMessage({
            success: false,
            message: error.toString()
          });
          
          throw error;
        }
      },

      createLanguageService() {
        return window.qsharpLanguageService;
      },
      
      // Register Monaco providers for the language service
      registerMonacoProviders: function() {
        logMessage("info", "Registering Monaco providers for Q#");
        
        // Register completion provider
        monaco.languages.registerCompletionItemProvider("qsharp", {
          triggerCharacters: [".", "@"],
          
          provideCompletionItems: async (model, position) => {
            logMessage("debug", `Completion requested at ${position.lineNumber}:${position.column}`);
            
            // Debug the model's language ID
            logMessage("debug", `Model language: ${model.getLanguageId()}`);
            
            // Skip if not our language
            if (model.getLanguageId() !== 'qsharp') {
              logMessage("debug", "Skipping completions for non-qsharp model");
              return { suggestions: [] };
            }
            
            try {
              const completions = await window.qsharpLanguageService.getCompletions(
                model.uri.toString(),
                monacoPositionToLsPosition(position)
              );
              
              if (completions && completions.items) {
                logMessage("debug", `Received ${completions.items.length} completion items`);
                
                return {
                  suggestions: completions.items.map((i) => {
                    let kind;
                    switch (i.kind) {
                      case "function": kind = monaco.languages.CompletionItemKind.Function; break;
                      case "interface": kind = monaco.languages.CompletionItemKind.Interface; break;
                      case "keyword": kind = monaco.languages.CompletionItemKind.Keyword; break;
                      case "variable": kind = monaco.languages.CompletionItemKind.Variable; break;
                      case "typeParameter": kind = monaco.languages.CompletionItemKind.TypeParameter; break;
                      case "module": kind = monaco.languages.CompletionItemKind.Module; break;
                      case "property": kind = monaco.languages.CompletionItemKind.Property; break;
                      case "field": kind = monaco.languages.CompletionItemKind.Field; break;
                      case "class": kind = monaco.languages.CompletionItemKind.Class; break;
                      default: kind = monaco.languages.CompletionItemKind.Text;
                    }
                    
                    return {
                      label: i.label,
                      kind: kind,
                      insertText: i.insertText || i.label,
                      sortText: i.sortText,
                      detail: i.detail,
                      documentation: i.documentation,
                      insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
                      additionalTextEdits: i.additionalTextEdits?.map((edit) => {
                        return {
                          range: lsRangeToMonacoRange(edit.range),
                          text: edit.newText
                        };
                      }),
                    };
                  })
                };
              } else {
                logMessage("warn", "Received empty completion response");
                return { suggestions: [] };
              }
            } catch (error) {
              logMessage("error", `Error getting completions: ${error.message}`);
              return { suggestions: [] };
            }
          }
        });
        
        // Register hover provider
        monaco.languages.registerHoverProvider("qsharp", {
          provideHover: async (model, position) => {
            // Skip if not our language
            if (model.getLanguageId() !== 'qsharp') {
              return null;
            }
            
            try {
              const hover = await window.qsharpLanguageService.getHover(
                model.uri.toString(),
                monacoPositionToLsPosition(position)
              );
              
              if (hover && hover.contents) {
                return {
                  contents: [{ value: hover.contents }],
                  range: hover.span ? lsRangeToMonacoRange(hover.span) : undefined
                };
              }
              return null;
            } catch (error) {
              logMessage("error", `Error getting hover: ${error.message}`);
              return null;
            }
          }
        });
        
        logMessage("info", "Monaco providers registered for Q#");
      },

      loadMonaco: function() {
        return new Promise((resolve, reject) => {
          try {
            require.config({
              paths: { 'vs': 'http://localhost:8080/vs' }
            });
            
            require(['vs/editor/editor.main'], () => {
              logMessage("info", "Monaco editor modules loaded successfully");
              this.monaco = monaco;
              document.getElementById('loading').style.display = 'none';
              resolve();
            });
          } catch (error) {
            logMessage("error", "Error loading Monaco: " + error.toString());
            reject(error);
          }
        });
      },

      setupQSharpLanguage: function() {
        logMessage("info", "Registering Q# language with Monaco");
        
        // Register the language
        monaco.languages.register({ id: 'qsharp' });
        
        // Set up syntax highlighting
        monaco.languages.setMonarchTokensProvider('qsharp', {
          defaultToken: '',
          tokenPostfix: '.qs',
          keywords: [
            'namespace', 'open', 'operation', 'function', 'body', 'adjoint', 'controlled',
            'if', 'elif', 'else', 'repeat', 'until', 'for', 'in', 'return', 'fail',
            'within', 'apply', 'using', 'borrow', 'use', 'let', 'mutable', 'set',
            'new', 'not', 'and', 'or', 'true', 'false'
          ],
          typeKeywords: [
            'Unit', 'Int', 'BigInt', 'Double', 'Bool', 'String', 'Qubit', 'Result',
            'Range', 'Array', 'Pauli', 'Zero', 'One'
          ],
          symbols: /[=><!~?&|+\-*/^%]+/,
          brackets: [
            { open: '{', close: '}', token: 'delimiter.curly' },
            { open: '[', close: ']', token: 'delimiter.square' },
            { open: '(', close: ')', token: 'delimiter.parenthesis' },
            { open: '<', close: '>', token: 'delimiter.angle' }
          ],
          tokenizer: {
            root: [
              [/\s+/, ''],
              [/\/\/.*$/, 'comment'],
              [/\/\*/, 'comment', '@comment'],
              [/"([^"\\]|\\.)*$/, 'string.invalid'],
              [/"/, 'string', '@string'],
              [/[a-zA-Z_]\w*/, {
                cases: {
                  '@keywords': 'keyword',
                  '@typeKeywords': 'type',
                  '@default': 'identifier'
                }
              }],
              [/\d*\.\d+([eE][\-+]?\d+)?/, 'number.float'],
              [/\d+/, 'number'],
              [/[{}()\[\]]/, '@brackets'],
              [/[<>](?!@symbols)/, '@brackets'],
              [/[+\-*/=<>!&|^%]+/, 'operator']
            ],
            comment: [
              [/[^/*]+/, 'comment'],
              [/\/\*/, 'comment', '@push'],
              [/\*\//, 'comment', '@pop'],
              [/[/\*]/, 'comment']
            ],
            string: [
              [/[^\\"]+/, 'string'],
              [/\\./, 'string.escape'],
              [/"/, 'string', '@pop']
            ]
          }
        });
        
        logMessage("info", "Q# language registered with Monaco");
      },

      createEditor: function() {
        logMessage("info", "Creating Monaco editor instance");
        
        // Create the model with the qsharp language
        const model = monaco.editor.createModel('', 'qsharp', monaco.Uri.parse('file:///main.qs'));
        
        // Create the editor with the model
        this.editor = monaco.editor.create(document.getElementById('container'), {
          model: model,
          language: 'qsharp',
          theme: 'vs-dark',
          automaticLayout: true,
          minimap: { enabled: false },
          wordWrap: 'on',
          fontSize: 14,
          lineNumbers: 'on',
          scrollBeyondLastLine: false,
          renderLineHighlight: 'all',
          tabSize: 4,
          insertSpaces: true
        });
        
        // Verify model is using qsharp language
        logMessage("info", `Editor created with language ID: ${this.editor.getModel().getLanguageId()}`);
        
        // Set up content change handler
        this.editor.onDidChangeModelContent(() => {
          try {
            const value = this.editor.getValue();
            logMessage("debug", "Editor content changed, length: " + value.length);
            
            // Send content to Swift
            window.webkit.messageHandlers.codeChanged.postMessage(value);
            
            // Update language service with the current content
            if (window.qsharpLanguageService) {
              const model = this.editor.getModel();
              window.qsharpLanguageService.updateDocument(
                model.uri.toString(),
                model.getVersionId(),
                value
              );
            }
          } catch (error) {
            logMessage("error", "Error in content change handler: " + error.toString());
          }
        });
        
        // Set up cursor position handler
        this.editor.onDidChangeCursorPosition((e) => {
          try {
            window.webkit.messageHandlers.cursorPositionChanged.postMessage({
              lineNumber: e.position.lineNumber,
              column: e.position.column
            });
          } catch (error) {
            logMessage("error", "Error in cursor position handler: " + error.toString());
          }
        });
        
        // Notify Swift that the editor is ready to receive content
        try {
          window.webkit.messageHandlers.editorReady.postMessage({});
          logMessage("info", "Sent editorReady message to Swift");
        } catch (error) {
          logMessage("error", "Error sending editorReady message: " + error.toString());
        }
      },
      
      // Update editor content with Swift code
      updateEditorContent: function(text) {
        logMessage("debug", "updateEditorContent called with text length: " + text.length);
        
        if (this.editor) {
          const currentValue = this.editor.getValue();
          if (currentValue !== text) {
            // Set the value in the editor
            this.editor.setValue(text);
            
            // Also update language service
            if (window.qsharpLanguageService) {
              const model = this.editor.getModel();
              window.qsharpLanguageService.updateDocument(
                model.uri.toString(),
                model.getVersionId(),
                text
              );
            }
            
            return true;
          }
          return false;
        } else {
          logMessage("error", "Editor not initialized when trying to update content");
          return false;
        }
      },
      
      // Set editor options
      setEditorOptions: function(options) {
        if (this.editor) {
          logMessage("debug", "Updating editor options: " + JSON.stringify(options));
          this.editor.updateOptions(options);
          return true;
        } else {
          logMessage("error", "Editor not initialized when trying to update options");
          return false;
        }
      },
      
      // Get current editor content
      getEditorContent: function() {
        if (this.editor) {
          return this.editor.getValue();
        }
        return null;
      }
    };

    // Global function to initialize the WASM service - no Promise return
    function initializeWasmService(wasmUrl, lsWorkerPath, compilerWorkerPath) {
      logMessage("info", "initializeWasmService called");
      logMessage("info", "WASM URL: " + wasmUrl);
      logMessage("info", "LS Worker URL: " + lsWorkerPath);
      logMessage("info", "Compiler Worker URL: " + compilerWorkerPath);
      
      window.qscBasePath = wasmUrl.substring(0, wasmUrl.lastIndexOf('/') + 1);
      window.qscWasmPath = wasmUrl;
      window.languageServiceWorkerPath = lsWorkerPath;
      window.compilerWorkerPath = compilerWorkerPath;
      
      // Start initialization but don't return the Promise
      if (window.QSharpLanguageService) {
        window.QSharpLanguageService.initialize(wasmUrl, lsWorkerPath, compilerWorkerPath)
          .catch(function(error) {
            logMessage("error", "Error during initialization: " + error.toString());
          });
      } else {
        logMessage("error", "QSharpLanguageService not found in WebView");
        try {
          window.webkit.messageHandlers.wasmServiceInitialized.postMessage({
            success: false,
            message: "QSharpLanguageService not found in the WebView"
          });
        } catch (error) {
          logMessage("error", "Error sending initialization error message: " + error.toString());
        }
      }
    }
    
    // Global functions to expose methods
    function updateEditorContent(text) {
      logMessage("debug", "updateEditorContent global function called with text length: " + text.length);
      if (window.QSharpLanguageService) {
        return window.QSharpLanguageService.updateEditorContent(text);
      } else {
        logMessage("error", "QSharpLanguageService not available when updating content");
        return false;
      }
    }
    
    function setEditorOptions(options) {
      if (window.QSharpLanguageService) {
        return window.QSharpLanguageService.setEditorOptions(options);
      } else {
        logMessage("error", "QSharpLanguageService not available when updating options");
        return false;
      }
    }
    
    function getEditorContent() {
      if (window.QSharpLanguageService) {
        return window.QSharpLanguageService.getEditorContent();
      }
      return null;
    }
    
    // Function to test completions manually
    function testCompletions() {
      try {
        logMessage("info", "Testing manual completions");
        
        if (!window.QSharpLanguageService || !window.QSharpLanguageService.editor) {
          logMessage("error", "Editor not available for testing");
          return;
        }
        
        const model = window.QSharpLanguageService.editor.getModel();
        const position = window.QSharpLanguageService.editor.getPosition();
        
        if (!model || !position) {
          logMessage("error", "Model or position not available");
          return;
        }
        
        // Log model details
        logMessage("info", `Model URI: ${model.uri.toString()}`);
        logMessage("info", `Model language: ${model.getLanguageId()}`);
        logMessage("info", `Position: ${position.lineNumber}:${position.column}`);
        
        // Try getting completions via the language service
        const lsPosition = monacoPositionToLsPosition(position);
        
        window.QSharpLanguageService.languageService.getCompletions(
          model.uri.toString(),
          lsPosition
        ).then(completions => {
          if (completions && completions.items) {
            logMessage("info", `Got ${completions.items.length} completion items from language service`);
            logMessage("info", `First few: ${JSON.stringify(completions.items.slice(0, 3))}`);
          } else {
            logMessage("warn", "No completion items returned from language service");
          }
        }).catch(error => {
          logMessage("error", `Error getting completions: ${error.message}`);
        });
        
        // Also try via Monaco's API
        const providers = monaco.languages.getCompletionItemProviders('qsharp');
        logMessage("info", `Found ${providers.length} completion providers for qsharp`);
        
        if (providers.length > 0) {
          providers[0].provideCompletionItems(model, position).then(result => {
            if (result && result.suggestions) {
              logMessage("info", `Got ${result.suggestions.length} suggestions from Monaco provider`);
            } else {
              logMessage("warn", "No suggestions returned from Monaco provider");
            }
          }).catch(error => {
            logMessage("error", `Error from Monaco provider: ${error.message}`);
          });
        }
      } catch (error) {
        logMessage("error", `Error testing completions: ${error.message}`);
      }
    }
    
    // Expose global functions
    window.initializeWasmService = initializeWasmService;
    window.updateEditorContent = updateEditorContent;
    window.setEditorOptions = setEditorOptions;
    window.getEditorContent = getEditorContent;
    window.testCompletions = testCompletions;

    // Notify Swift when the page and scripts are fully loaded
    window.onload = function() {
      logMessage("info", "Page fully loaded. JS environment is ready.");
      try {
        window.webkit.messageHandlers.jsReady.postMessage("ready");
      } catch(e) {
        console.warn("jsReady handler not available:", e);
      }
    };
  </script>
</body>
</html>
